{%- macro PeriodPrice(mySensor_today,
                      earliestDatetime=null, latestDatetime=null,
                      durationTimedelta=timedelta(minutes=60),
                      returnFirstBool=true,
                      timeAdherenceStr="default",
                      attr_today_arr="raw_today",
                      attr_tomorrow_arr="raw_tomorrow",
                      mySensor_tomorrow = mySensor_today,
                      attr_forecast_arr="forecast",
                      mySensor_forecast = mySensor_today,
                      timeTagStr="hour",
                      priceTagStr="price",
                      defaultDurationMinNum=30,
                      defaultPeriodHrsNum=48,
                      mode="default",
                      hint="",
                      slices=1,
                      kwh_usage=[]
                    ) -%}

  {#-####################################################################-#}
  {#-
    Note that makro can be called adding just the mySensor_today parameter. Any parameter can be added in any order
    providing that it is written using the parameter name. When leaving out parameters, this is mandatory to ensure
    correct parsing. E.g. {{- PeriodPrice("sensor.edssensor", durationTimedelta=timedelta(minutes=90)) -}} 

    Required = *
    * mySensor_today        (String) Name of the sensor (EDS or any similar type of sensor) that contains pricing data
    edsearliestDatetime     (DateTime) Exact date/time of start of window during which electricity will be used
    latestDatetime          (DateTime) Exact date/time of end of window during which electricity will be used
    durationTimedelta       (TimeDelta) Duration of electricity usage formatted as a TimeDelta
    returnFirstBool         (Boolean) Default to true to use first occurrence of the lowest price, otherwise use the last
    timeAdherenceStr        (String) Influences the behaviour when seeking low / high cost
                            - default = adjusts time to 'now' if time is in the past
                            - strict  = do not adjust time and return empty result if window is in the past
                            - forced  = do not adjust time and return result even if window is in the past
    attr_today_arr          (String) Name of attribute for today data - organized in pairs of time + price
    attr_tomorrow_arr       (String) Name of attribute for tomoows data (if any) - organized in pairs of time + price
    attr_forecast_arr       (String) Name of attribute for forecast data after tomorrow (if any) - organized in pairs of time + price
    timeTagStr              (String) Name attribute (in the pair) containng the time
    priceTagStr             (String) Name attribute (in the pair) containng the price
    defaultDurationMinNum   (Number) Default minimum duration of a 
    defaultPeriodHrsNum     (Number) The default duration of hour to look for cheapest prices
    mode                    full / 
                            cheapPrice / cheapStart / cheapStart / isCheapNow
                            expensivePrice / expensiveStart / expensiveStart / isExpensiveNow
    hint                    String to be returned as part of the result. This could (e.g.) be the name of the integration providing data
    slices                  Number (1-60) of an hour if the prices retrieved from mySensor is less than an hour (e.g. 30mins), then the
                            acceptable range will also be reduced.

    Macro returns a STRING(!) based on the MODE setting
    mode = full
      String that must be converted using the from_json filter. The JSON can contain following:
        * cheapPriceStartTime      Datetime string of when cheapest time starts
        * cheapPriceEndTime        Datetime string of when cheapest time ends
        cheapPrice                 Price if 1 kW is used each hour during cheapest time. None if no period found
        * expensivePriceStartTime  Datetime string of when most expensive time starts
        * expensivePriceEndTime    Datetime string of when most expensive time ends
        expensivePrice             Price if 1 kW is used each hour during most expensive time. None if no period found
        earliestDatetime           Datetime string of the earliest time used when looking for cheap / expensive
        latestDatetime             Datetime string of the latest time used when looking for cheap / expensive
        duration                   The duration of the time window looked for (in minutes)
        isCheapNow                 none if no cheap time period found, otherwise true / false dependent on whether right now is the cheapest period 
        isExpensiveNow             none if no expensive time period found, otherwise true / false dependent on whether right now is the most expensive period
        hint                       none or string as provided when  macro was called 
        * = only included if a corresponding period was found
    mode = cheapPrice
      String value of price if 1 kW is used each hour during cheapest time. None if no period found
    mode = cheapStart
      Datetime string of when cheapest time starts
    mode = cheapEnd
      Datetime string of when cheapest time ends
    mode = expensivePrice
      String value of price if 1 kW is used each hour during most expensive time. None if no period found
    mode = expensiveStart
      Datetime string of when most expensive time starts
    mode = expensiveEnd
      Datetime string of when most expensive time ends
  -#}

  {#-####################################################################-#}
  {#- Prepare input parameters -#}
  
  {#- Blank out unwanted date sets. Order is today -> tomorrow -> forecast. If a set is blanked out, subsequent set(s) are also be blanked out -#}
  {%- if attr_today_arr=="" -%}
    {%- set attr_tomorrow_arr = "" -%}
    {%- set mySensor_tomorrow = "" -%}
  {%- endif -%}
  {%- if attr_tomorrow_arr=="" -%}
    {%- set attr_forecast_arr = "" -%}
    {%- set mySensor_forecast = "" -%}
  {%- endif -%}
  
  {#- Retrieve energy prices -#}
  {%- set prices        = ( state_attr(mySensor_today, attr_today_arr) or []) +
                           (state_attr(mySensor_tomorrow, attr_tomorrow_arr) or []) +
                           (state_attr(mySensor_forecast, attr_forecast_arr) or []) -%}
  {%- set prices_len = prices | length -%}

  {%- if prices == [] %} 
    {%- set status="noPrices" -%}
  {%- else -%}
    {%- if timeTagStr not in prices[0] or priceTagStr not in prices[0] -%}
      {%- set prices=[] -%}
      {%- set prices_len = 0 -%}
      {%- set status="incorrectTagsProvided" -%}   
    {%- else -%}
      {%- if slices is not number or slices not in [1,2,3,4,5,6,10,12,15,20,30,60] -%}
        {%- set status="invalidSlice" -%}
      {%- else -%}
        {%- set status = "ok" -%}
        {%- if kwh_usage is sequence and kwh_usage !=[] and kwh_usage is not string -%}
          {%- set sliceWindow = 60 / slices -%}
        {%- else -%}
          {%- set sliceWindow = 60 -%}
          {%- set slices = 1 -%}    
        {%- endif -%}
      {%- endif -%}

      {%- if prices | length >= 2 -%}
        {%- set priceWindow = ((prices[1][timeTagStr] - prices[0][timeTagStr]).total_seconds() / 60) | int(60) -%}
        {%- set pricesPerHour = 60 / priceWindow -%}
      {%- else -%}
        {%- set priceWindow = 60 -%}
        {%- set pricesPerHour = 1 -%}    
      {%- endif -%}
    {%- endif -%}
  {%- endif -%}

  {%- if status == "ok" -%}
    {%- if (priceWindow != sliceWindow) and (priceWindow % sliceWindow == 0) -%}
      {#- Split priceWindow -#}
      {%- set tmpSet = namespace(dict = []) -%}
      {%- set factor = (priceWindow / sliceWindow) | int %}
      {%- set priceWindow = priceWindow / factor -%}
      {%- set pricesPerHour = pricesPerHour * factor -%}     
      {%- for entry in prices -%}
        {%- for i in range(factor) -%}
          {%- set tmpSet.dict = tmpSet.dict + [{timeTagStr:(entry[timeTagStr] + timedelta(minutes=priceWindow*i)),priceTagStr:entry[priceTagStr] | round(8)}] -%}
        {%- endfor -%}
      {%- endfor -%}
      {%- set prices = tmpSet.dict -%}
    {%- endif -%}

    {%- if (priceWindow != sliceWindow) and (sliceWindow % priceWindow == 0) -%}
      {#- Split priceWindow -#}
      {%- set tmpSet = namespace(dict = []) -%}
      {%- set factor = (sliceWindow / priceWindow) | int-%}
      {%- set sliceWindow = sliceWindow / factor -%}
      {%- set slices = slices * factor -%}     
      {%- for entry in kwh_usage -%}
        {%- for i in range(factor) -%}
          {%- set tmpSet.dict = tmpSet.dict + [entry / factor]  -%}
        {%- endfor -%}
      {%- endfor -%}
      {%- set kwh_usage = tmpSet.dict -%}
    {%- endif -%}
  {%- endif -%}

  {#- Validate and set durationTimedelta -#}
  {%- set minDuration            = defaultDurationMinNum if defaultDuration is number else 30 -%}
  {%- set durationTimedelta      = timedelta(minutes=minDuration) if durationTimedelta is not defined or durationTimedelta < timedelta(minutes=minDuration) else durationTimedelta -%}
  {%- set durationMinutes        = durationTimedelta.total_seconds() | int(minDuration * priceWindow) // 60 -%}
  {%- set durationMinutesResidual= durationMinutes % priceWindow -%}
  {%- set durationHours          = ((durationMinutes // priceWindow) + (1 if durationMinutesResidual > 0 else 0)) | int -%}

  {%- set reqUsageSlices = ((1 if durationMinutes % priceWindow != 0 else 0) + (durationMinutes // priceWindow)) | int -%}
  {%- if kwh_usage is not sequence and kwh_usage is number -%}
    {%- set slices = pricesPerHour -%}
    {%- set sliceWindow = priceWindow -%}
    {%- set tmp = kwh_usage / (durationMinutes / priceWindow) -%}
    {%- set tmpSet = namespace(dict = []) -%}  
    
    {%- for i in range((durationMinutes // priceWindow) | int) -%}
      {%- set tmpSet.dict = tmpSet.dict + [tmp] -%}
    {%- endfor -%}
    {%- if durationMinutes % priceWindow != 0 -%}
      {%- set tmpSet.dict = tmpSet.dict + [kwh_usage - tmp * reqUsageSlices] -%}
    {%- endif -%}
    {% set kwh_usage = tmpSet.dict -%}
  {%- endif -%}

  {%- set usageLen = kwh_usage | length if kwh_usage is sequence and kwh_usage is not string else 0 -%} 
  {%- if usageLen==0 -%}
    {%- set kwh_usage=[] -%}
    {%- set slices = 1 -%}
    {%- set sliceWindow = 60 -%}
  {%- elif usageLen>reqUsageSlices -%}
    {%- set kwh_usage=kwh_usage[:reqUsageSlices] -%}
  {%- elif usageLen<reqUsageSlices -%}
    {%- set status="notEnoughKwhPoints" -%}
  {%- endif -%}

  {%- set arrSize    = prices | length -%}
  {%- set prices_len = arrSize - durationHours | int + 1 -%}
  
  {%- set timeAdherenceStr       = timeAdherenceStr | lower %}
  {%- if timeAdherenceStr not in ("default", "strict", "forced") %}
      {% set timeAdherenceStr = "default" %}
  {%- endif -%}
  {%- set nowTime                = now() if timeAdherenceStr not in ("strict", "forced") else earliestDatetime -%}
 
  {#-###################################-#}
  {#- Validate and set earliestDatetime -#}
  {%- set earliestDatetime       = nowTime if earliestDatetime is not defined or earliestDatetime is not datetime or (earliestDatetime < nowTime) else earliestDatetime -%}
  {#- Strip microseconds and seconds from time -#}
  {%- set earliestDatetime       = earliestDatetime - timedelta(microseconds=earliestDatetime.microsecond, seconds=earliestDatetime.second) -%}
  {%- set earliestDatetimeMinute = earliestDatetime.minute -%}
  {%- set earliestDatetimeComp   = earliestDatetime - timedelta(minutes=earliestDatetime.minute, seconds=earliestDatetime.second) -%}

  {#-###################################-#}
  {#- Validate and set latestDatetime -#}
  {%- set defPeriodeHours        = defaultPeriodHrsNum if defaultPeriodHrsNum is number else 48 -%}
  {%- set latestDatetime         = nowTime + timedelta(hours=defPeriodeHours) if latestDatetime is not defined or latestDatetime is not datetime or latestDatetime < earliestDatetime else latestDatetime -%}
  {#- Strip microseconds from time -#}
  {%- set latestDatetime         = latestDatetime - timedelta(microseconds=latestDatetime.microsecond) -%}
  {%- set latestDatetimeMinut    = latestDatetime.minute -%}
  {%- set latestDatetime         = latestDatetime + timedelta(minutes=0 if latestDatetimeMinut == 0 else (priceWindow-latestDatetimeMinut)% priceWindow, seconds=-latestDatetime.second) -%}
  {#- 
     Extend latestDatetime in case a duration is provided that exceeds the provided latestDatetime
     Note: latestDatetime is only extended by as many minutes as the window is exceeded with
  -#}
  {%- set durationDiff           = durationMinutes - (latestDatetime - earliestDatetime).total_seconds() // priceWindow -%}
  {%- set durationDiff           = 0 if durationDiff < 0 else durationDiff -%}
  {%- set latestDatetime         = latestDatetime + timedelta(minutes=0 if durationDiff <= 0 else durationDiff) -%}
  {#%- set latestDatetimeComp     = (latestDatetime - timedelta(hours=durationHours + (1 if durationMinutesResidual > 0 else 0))) -%#}
  {%- set mode                   = mode | lower -%}
 
  {%- if mode not in (
                        "default", "details",
                        "cheapPrice", "cheapStart", "cheapStart", "isCheapNow", 
                        "expensivePrice", "expensiveStart", "expensiveStart", "isExpensiveNow"
                      ) -%}
    {%- set mode = "default" -%}
  {% endif %}

  {%- if status == "ok" %}
    {#- If, under 'strict' time adherence, where the provided latestDatetime is in the past, return an error -#}
    {%- set validTime = (timeAdherenceStr != "strict") or ( (timeAdherenceStr == "strict") and (latestDatetime >= now()) ) -%} 
    {%- if not validTime -%} 
      {%- set status="windowInPast" %}
    {%- endif -%}
  {%- endif -%}
  
  {#-####################################################################-#}
  {#- Set result name spaces -#}
  {%- set resultCheap     = namespace(pricing=9999, priceStartTime=None, window=[]) -%}
  {%- set resultExpensive = namespace(pricing=0,    priceStartTime=None, window=[]) -%}

  {#-####################################################################-#}
  {#- Only run if we have price data and no error so far -#}
  {%- if prices_len > 0 and status=="ok" -%}
    {#- Do not allow latestDatetime to be after last price available - makes no sense -#}
    {%- set tmp = prices[arrSize-1][timeTagStr] + timedelta(minutes=priceWindow) -%}
    {%- if latestDatetime > tmp -%}
      {%- set latestDatetime = tmp -%}
    {%- endif -%}
    
    {#-####################################################################-#}
    {#-
       Calculate cheapest period for the current hour and all consecutive hours
       Note: This will take the current hour into account thus providingg a calculation for now() + duration,
             as well at calculation placed at the end of a hour
    -#}
    {#- Loop all timeslot where a pricing exists -#}
    {%- set loopSet = [0] -%}
    {%- if durationMinutesResidual != 0 -%}
      {%- set tmpVal = priceWindow - durationMinutesResidual -%}
      {%- set loopSet = loopSet + ([] if tmpVal in loopSet else [tmpVal]) -%}
    {%- endif -%}
    {%- for n in range(prices_len) -%}
      {#- Calculat pricing on the hour, at the current minute number as well as at the end of an hour -#}
      {%- if (prices[n][timeTagStr]).minute <=  earliestDatetimeMinute <= (prices[n][timeTagStr] + timedelta(minutes=priceWindow-1)).minute -%}
        {%- set tmpVal = earliestDatetimeMinute % priceWindow -%}
        {%- set loopSet = loopSet + ([] if tmpVal in loopSet else [tmpVal]) -%}
      {%- endif -%}     

      {#- Iterate through the possible minute sets -#}
      {%- for v in range(loopSet | length) -%}
        {%- set priceStartTime     = prices[n][timeTagStr] + timedelta(minutes=loopSet[v]) -%}
        {%- if earliestDatetimeComp <= priceStartTime -%}
        {#-####################################################################-#}
        {#- Only do the calculation for price data that falls within the relevant timespan -#}
        {%- set usagePos = namespace(pos=0) -%}
        {%- set minLeft = priceWindow - loopSet[v] -%}
        {%- set workMin = loopSet[v] -%}
        
        {%- set timeResidual = namespace(value=durationMinutes) -%}
        {%- set initTime = min(minLeft, timeResidual.value) -%}
        {%- set timeResidual.value = timeResidual.value - initTime -%}
        
        {%- set kwh = 1 if usageLen == 0 else kwh_usage[usagePos.pos] -%}
        {%- set priceFactor = (initTime / priceWindow) if usageLen == 0 else (kwh * initTime / priceWindow) -%}
        {%- set period = (priceWindow * priceFactor / kwh) | int -%}
        {%- set pricing = namespace(value=prices[n][priceTagStr] * priceFactor) -%}
        
        {%- set timeSet = namespace(dict=[ dict(start=(prices[n][timeTagStr] + timedelta(minutes=workMin)) | string, minutes=period, kWh_price=prices[n][priceTagStr], est_kWh=priceFactor | round(4) ) ]) -%}
        
        {%- set initTime = initTime % priceWindow if usageLen != 0 else 0 -%}
        {%- set usageTime = initTime -%}
        {%- set priceStartTime = priceStartTime - timedelta( minutes=0 if durationDiff <= 0 else priceWindow - durationDiff ) -%}
        
        {%- if priceStartTime >= earliestDatetime and (priceStartTime + timedelta(minutes=durationMinutes)) <= latestDatetime -%}
            
            {%- for i in range(durationHours) if n + i + 1 < arrSize -%}
                {%- set workMin = min(timeResidual.value, priceWindow) if timeResidual.value > 0 else 0 -%}
                
                {%- if period != priceWindow and usageLen > 0 and timeResidual.value > 0 -%}
                    {%- set initTime = min(workMin, priceWindow - usageTime) -%}
                    {%- set kwh = 1 if usageLen == 0 else kwh_usage[usagePos.pos] -%}
                    {%- set priceFactor = kwh * initTime / priceWindow -%}
                    {%- set period = (priceWindow * priceFactor / kwh) | int -%}
                    {%- set pricing.value = pricing.value + prices[n + i + 1][priceTagStr] * priceFactor -%}
                    
                    {%- if priceFactor != 0 -%}
                        {%- set timeSet.dict = timeSet.dict + [ dict( start=prices[n + i + 1][timeTagStr] | string, minutes=period, kWh_price=prices[n + i + 1][priceTagStr], est_kWh=priceFactor | round(4) ) ] -%}
                    {%- endif -%}
                    
                    {%- set timeResidual.value = timeResidual.value - initTime -%}
                {%- endif -%}
        
                {%- set usagePos.pos = usagePos.pos + 1 -%}
                {%- set kwh = 1 if usageLen == 0 else kwh_usage[usagePos.pos] -%}
        
                {%- if timeResidual.value > 0 -%}
                    {%- set offset = initTime -%}
                    {%- set initTime = min(timeResidual.value, priceWindow - initTime) -%}
                    {%- set priceFactor = (initTime / priceWindow) if usageLen == 0 else (kwh * initTime / priceWindow) -%}
                    {%- set period = (priceWindow * priceFactor / kwh) | int -%}
                    {%- set pricing.value = pricing.value + prices[n + i + 1][priceTagStr] * priceFactor -%}
        
                    {%- if priceFactor != 0 -%}
                        {%- set timeSet.dict = timeSet.dict + [ dict( start=(prices[n + i + 1][timeTagStr] + timedelta(minutes=offset)) | string, minutes=period, kWh_price=prices[n + i + 1][priceTagStr], est_kWh=priceFactor | round(4) ) ] -%}
                    {%- endif -%}
                    
                    {%- set timeResidual.value = timeResidual.value - initTime -%}
                {%- endif -%}
        
                {%- if usageTime == priceWindow or usageLen == 0 -%}
                    {%- set usagePos.pos = usagePos.pos + 1 -%}
                {%- endif -%}
            {%- endfor -%}

            {#-####################################################################-#}
            {%- if (pricing.value<resultCheap.pricing or
                   (returnFirstBool and pricing.value<=resultCheap.pricing and priceStartTime<resultCheap.priceStartTime) or
                   (not returnFirstBool and pricing.value<=resultCheap.pricing and priceStartTime>resultCheap.priceStartTime)
                   ) -%}
              {%- set resultCheap.pricing        = pricing.value -%}
              {%- set resultCheap.priceStartTime = priceStartTime -%}
              {%- set resultCheap.window = timeSet.dict -%}
            {%- endif -%}
            {%- if (pricing.value>resultExpensive.pricing or
                   (returnFirstBool and pricing.value>=resultExpensive.pricing and priceStartTime<resultExpensive.priceStartTime) or
                   (not returnFirstBool and pricing.value>=resultExpensive.pricing and priceStartTime>resultExpensive.priceStartTime)
                   ) -%}
              {%- set resultExpensive.pricing        = pricing.value -%}
              {%- set resultExpensive.priceStartTime = priceStartTime -%}
              {%- set resultExpensive.window = timeSet.dict -%}
            {%- endif -%}
          {%- endif -%}
        {%- endif -%}
      {%- endfor -%}
    {%- endfor -%}
  {%- endif -%}

  {#-####################################################################-#}
  {#- Output result as a string formatted as JSON - this can then be parsed by whatever called the macro -#}
  {%- set FinalCheapDict     = dict(cheapPrice=none)     if resultCheap.pricing     == 9999 or resultCheap.priceStartTime    ==None else dict(cheapPriceStartTime    =resultCheap.priceStartTime    |string, cheapPrice    =resultCheap.pricing    |round(4)) -%}
  {%- set FinalExpensiveDict = dict(expensivePrice=none) if resultExpensive.pricing == 9999 or resultExpensive.priceStartTime==None else dict(expensivePriceStartTime=resultExpensive.priceStartTime|string, expensivePrice=resultExpensive.pricing|round(4)) -%}
  {%- if (FinalCheapDict.cheapPrice is none or FinalExpensiveDict.expensivePrice is none) and status=="ok" -%}
    {% set status="noWindowFound" %}
  {%- endif -%}
  
  {%- set result = dict(status=status,
                        **(dict() if hint == "" else dict(hint = hint))) -%}
  {%- set result = result if mode != "details" else
                    dict( cheapWindow=resultCheap.window,
                          expensiveWindow=resultExpensive.window,
                          pricingWindow   = priceWindow | int,
                          sliceWindow     = sliceWindow | int,
                          **result) -%}
  {%- set result = dict(earliestDatetime= earliestDatetime|string, 
                        latestDatetime  = latestDatetime|string, 
                        duration        = durationMinutes|round(0),
                        isCheapNow      = none if FinalCheapDict.cheapPrice        ==none else now() | as_timestamp | timestamp_custom('%Y-%m-%d %H:%M') == FinalCheapDict.cheapPriceStartTime         | as_timestamp | timestamp_custom('%Y-%m-%d %H:%M'),
                        isExpensiveNow  = none if FinalExpensiveDict.expensivePrice==none else now() | as_timestamp | timestamp_custom('%Y-%m-%d %H:%M') == FinalExpensiveDict.expensivePriceStartTime | as_timestamp | timestamp_custom('%Y-%m-%d %H:%M'),
                        mode            = mode,
                        **result) -%}
  {%- set result = dict(FinalCheapDict | items | list +
                        FinalExpensiveDict | items | list,
                       **result) -%}  

  {%- if mode == "cheapPrice" -%}
    {{- result.cheapPrice -}}
  {%- elif mode == "cheapStart" -%}
    {{- (result.cheapPriceStartTime if result.cheapPrice != none else none) | trim -}}
  {%- elif mode == "cheapStart" -%}
    {{- result.cheapPriceEndTime if result.cheapPrice != none else none -}}
  {%- elif mode == "isCheapNow" -%}
    {{- result.isCheapNow -}}
  {%- elif mode == "expensivePrice" -%}
    {{- result.expensivePrice -}}
  {%- elif mode == "expensiveStart" -%}
    {{- result.expensivePriceStartTime if result.expensivePrice != none else none -}}
  {%- elif mode == "expensiveStart" -%}
    {{- result.expensivePriceEndTime if result.expensivePrice != none else none -}}
  {%- elif mode == "isExpensiveNow" -%}
    {{- result.isExpensiveNow -}}
  {%- else -%}
    {{- result | to_json -}}
  {%- endif -%}
{%- endmacro -%}
